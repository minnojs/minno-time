{"version":3,"file":"Scorer.js","sources":["computeD.js","msgMan.js","parcelMng.js","Scorer.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * Essentialy a defaults object for the scorer\n */\ndefine('pipScorer/computeD',['require','jquery'],function(require){\n\tvar $ = require('jquery');\n\n\tfunction ComputeD(){\n\t\t$.extend(this, {\n\t\t\tdataArray : {}, //The data array or structure the PIP will provide\n\t\t\tAnalyzedVar : \"latency\", //The main variable used for the score computation. Usually will be the latency.\n\t\t\tErrorVar : \"error\", //The variable that indicates whether there was an error in the response\n\t\t\tcondVar:\"\",  //The name of the variable that will store the variables\n\t\t\tcond1VarValues: [], //An array with the values of the condVar that will comprise of condition 1 in the comparison\n\t\t\tcond2VarValues: [], //An array with the values of the condVar that will comprise of condition 2 in the comparison\n\t\t\tparcelVar : \"\",\n\t\t\tparcelValue : [],\n\t\t\tfastRT : 300, //Below this reaction time, the latency is considered extremely fast.\n\t\t\tmaxFastTrialsRate : 0.1, //Above this % of extremely fast responses within a condition, the participant is considered too fast.\n\t\t\tminRT : 400, //Below this latency\n\t\t\tmaxRT : 10000, //above this\n\t\t\tmaxErrorParcelRate: 0.4,\n\t\t\terrorLatency : {use:\"latency\", penalty:600, useForSTD:true},\n\t\t\tpostSettings : {}\n\t\t});\n\t}\n\n\t$.extend(ComputeD.prototype, {\n\t\tsetComputeObject: function(obj){\n\t\t\t$.extend(this,obj);\n\t\t},\n\n\t\tsetDataArray: function(){\n\t\t\t// use the real global in order to preven problems with dependencies\n\t\t\tvar global = window.piGlobal;\n\n\t\t\tthis.dataArray = global.current.logs;\n\t\t}\n\n\t});\n\n\treturn ComputeD;\n});\n","define('pipScorer/msgMan',['require','underscore'],function(require){\n\tvar _ = require('underscore');\n\n\tvar messages = {\n\t\tMessageDef:[],\n\t\tmanyErrors: \"There were too many errors made to determine a result.\",\n\t\ttooFast: \"There were too many fast trials to determine a result.\",\n\t\tnotEnough: \"There were not enough trials to determine a result.\"\n\t};\n\n\tfunction Message(){\n\t\t// setup default local messages\n\t\tthis.messages = _.extend({}, messages);\n\t}\n\n\t_.extend(Message.prototype, {\n\n\t\t/**\n\t\t * Setup custom local messages\n\t\t * @param {Object} Obj \tmessages object\n\t\t */\n\t\tsetMsgObject: function(Obj){\n\t\t\t_.extend(this.messages,Obj);\n\t\t},\n\n\t\tgetScoreMsg: function(score){\n\n\t\t\tvar array = this.messages.MessageDef;\n\n\t\t\tif (!array || !array.length){\n\t\t\t\tthrow new Error('You must define a \"MessageDef\" array.');\n\t\t\t}\n\n\t\t\tvar scoreNum = parseFloat(score);\n\t\t\tvar cut = null;\n\t\t\tvar msg = null;\n\t\t\tvar rightMsg = 'error: msg was not set';\n\t\t\tvar set = false;\n\n\t\t\t// @TODO repleace this whole section with a \"_.find()\" or something.\n\t\t\t_.each(array, function(val) {\n\t\t\t\tcut = parseFloat(val.cut);\n\t\t\t\tmsg = val.message;\n\t\t\t\tif (scoreNum<=cut && !set){\n\t\t\t\t\trightMsg = msg;\n\t\t\t\t\tset = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!set){\n\t\t\t\tvar length = array.length;\n\t\t\t\tvar obj = array[length-1];\n\t\t\t\trightMsg = obj.message;\n\t\t\t}\n\n\t\t\treturn rightMsg;\n\t\t},\n\n\t\tgetMessage: function getMessage(type){\n\t\t\treturn this.messages[type];\n\t\t}\n\t});\n\n\treturn Message;\n});\n","define('pipScorer/parcelMng',['require','underscore'],function(require){\n\n\tvar _ = require('underscore');\n\n\tfunction ParcelMng(msgMan){\n\t\tthis.parcelArray = []; // Holds parcel array\n\t\tthis.scoreData = {}; // Holds score and error message\n\t\tthis.msgMan = msgMan;\n\t}\n\n\t_.extend(ParcelMng.prototype, {\n\n/*  Method: Void Init\n\tInput: Uses logs from API\n\tOutput: Sets parcelArray with array of type parcel\n\tDescription: Init goes over the log and creates an array of object of type Parcel according to\n\tthe parcelValue array in computeD. Each parcel object holds relevant information regarding the\n\tparcel including an array of trials with the relevant parcel name.\n\n\n*/\n\t\tInit: function(compute){\n\t\t\tvar parcelMng = this;\n\t\t\tvar msgMan = this.msgMan;\n\t\t\t// use the real global in order to prevent problems with dependencies\n\t\t\tvar global = window.piGlobal;\n\n\t\t\tvar data = global.current.logs;\n\t\t\tparcelMng.parcelArray = [];\n\t\t\tparcelMng.scoreData = {};\n\t\t\tparcelMng.msgMan = msgMan;\n\n\t\t\t// get settings\n\t\t\tvar AnalyzedVar = compute.AnalyzedVar;\n\t\t\tvar error = compute.ErrorVar;\n\t\t\tvar parcelVar = compute.parcelVar;\n\t\t\tvar parcels = compute.parcelValue;\n\t\t\tvar min = compute.minRT;\n\t\t\tvar max = compute.maxRT;\n\t\t\tvar fastRT= compute.fastRT;\n\n\t\t\t// set counters\n\t\t\tvar totalScoredTrials = 0;\n\t\t\tvar trialsUnder = 0;\n\t\t\tvar totalTrials=0;\n\t\t\tvar totalErrorTrials =0;\n\t\t\tvar maxFastTrialsRate = parseFloat(compute.maxFastTrialsRate);\n\n\n\t\t\tif (typeof parcels == 'undefined' || parcels.length === 0){\n\t\t\t\ttotalTrials =0;\n\t\t\t\ttotalScoredTrials=0;\n\t\t\t\ttrialsUnder=0;\n\t\t\t\ttotalErrorTrials=0;\n\t\t\t\tvar p = {};\n\t\t\t\tp.name = 'general';\n\t\t\t\tp.trialIData = [];\n\t\t\t\t_.each (data, function (value) {// loop per object in logger\n\t\t\t\t\t\tif (value[AnalyzedVar]>=min && value[AnalyzedVar]<=max){\n\t\t\t\t\t\t\ttotalTrials++;\n\t\t\t\t\t\t\tif (value.data[error] == 1) {\n\t\t\t\t\t\t\t\ttotalErrorTrials++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//p.trialIData.push(value);//push all data\n\t\t\t\t\t\t\t//totalScoredTrials++;\n\t\t\t\t\t\t\tif (parcelMng.validate(p,value,compute)) {\n\t\t\t\t\t\t\t\ttotalScoredTrials++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tif (value[AnalyzedVar]<= fastRT) {\n\t\t\t\t\t\t\t\ttrialsUnder++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tparcelMng.checkErrors(totalTrials,totalErrorTrials,compute);\n\t\t\t\tparcelMng.parcelArray[0] = p;\n\t\t\t} else {\n\t\t\t\t_.each (parcels, function(parcelName,index) {// per parcel from parcelValue\n\t\t\t\t\t//set variables calculated per parcel\n\t\t\t\t\ttotalTrials =0;\n\t\t\t\t\ttotalScoredTrials=0;\n\t\t\t\t\ttrialsUnder=0;\n\t\t\t\t\ttotalErrorTrials=0;\n\t\t\t\t\tvar p = {};\n\t\t\t\t\tp.name = parcelName;\n\t\t\t\t\tp.trialIData = [];\n\t\t\t\t\t///////////////////////////////////\n\t\t\t\t\t_.each (data, function (value) {//loop per object in logger\n\t\t\t\t\t\tvar trialParcelName = value.data[parcelVar];\n\n\t\t\t\t\t\t// if this trial belongs to parcel\n\t\t\t\t\t\tif (trialParcelName == parcelName){\n\t\t\t\t\t\t\tif (value[AnalyzedVar]>=min && value[AnalyzedVar]<=max){\n\t\t\t\t\t\t\t\ttotalTrials++;\n\t\t\t\t\t\t\t\tif (value.data[error] == 1) {\n\t\t\t\t\t\t\t\t\ttotalErrorTrials++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//p.trialIData.push(value);//push all data\n\t\t\t\t\t\t\t\t//totalScoredTrials++;\n\t\t\t\t\t\t\t\tif (parcelMng.validate(p,value,compute)) {\n\t\t\t\t\t\t\t\t\ttotalScoredTrials++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\tif (value[AnalyzedVar]<= fastRT) {\n\t\t\t\t\t\t\t\t\ttrialsUnder++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\t\t\t\t\tparcelMng.checkErrors(totalTrials,totalErrorTrials,compute);//apply maxErrorParcelRate logic\n\t\t\t\t\tparcelMng.parcelArray[index] = p;\n\t\t\t\t});\n\t\t\t}\n\t\t\tif ( (trialsUnder/totalScoredTrials) > maxFastTrialsRate){\n\t\t\t\tparcelMng.scoreData.errorMessage = this.msgMan.getMessage('tooFast');\n\n\t\t\t}\n\n\t\t},\n\n/*\n\tprivate\n\tMethod: Void checkErrors\n\tInput: totalTrials,totalErrorTrials and compute object.\n\tOutput: Sets scoreData with error message if relevant.\n\tDescription: Helper method to check for errors according to maxErrorParcelRate from compute object.\n\tsets an error message in scoreData.\n\n*/\n\t\tcheckErrors: function(totalTrials,totalErrorTrials,compute){\n\n\t\t\tvar maxErrorParcelRate = compute.maxErrorParcelRate;\n\t\t\tif (totalErrorTrials/totalTrials > maxErrorParcelRate){\n\t\t\t\tthis.scoreData.errorMessage = this.msgMan.getMessage('manyErrors');\n\n\t\t\t}\n\n\t\t},\n\n/* Function: Void validate.\n\tInput: parcel object, trial object from the log and the compute object.\n\tOutput: Pushes the trial to the parcel based on information from errorLatency. Returns true/false.\n\tDescription: Helper method to apply errorLatency logic. If set to 'latency' trials witch are error\n\twould be added to the parcel trial array. if set to false trials that are error would not be added,\n\tif set to panelty error trials will be added and later panelized.\n\n*/\n\n\t\tvalidate: function(p,value,compute){\n\t\t\tvar errorLatency = compute.errorLatency;\n\t\t\tvar error = compute.ErrorVar;\n\t\t\tvar data = value.data;\n\n\n\t\t\tif (errorLatency.use =='latency'){\n\t\t\t\tp.trialIData.push(value);\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\tif (errorLatency.use =='false'){\n\t\t\t\t\tif(data[error]=='1'){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tp.trialIData.push(value);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(errorLatency.use =='penalty'){\n\t\t\t\t\tp.trialIData.push(value);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n/*  Function: Void addPenalty.\n\tInput: parcel object and the compute object.\n\tOutput: adds penalty to latency of trials\n\tDescription: Helper method to add average and penalty to error trials\n\tif errorLatency is set to 'penalty'. Should be called after avgAll.\n\n*/\n\n\t\taddPenalty: function(p,compute){\n\t\t\tvar errorLatency = compute.errorLatency;\n\t\t\tvar parcelMng = this;\n\n\n\t\t\tif (errorLatency.use == 'penalty'){\n\n\t\t\t\tvar penalty = parseFloat(errorLatency.penalty);\n\t\t\t\tvar ErrorVar = compute.ErrorVar;\n\t\t\t\tvar AnalyzedVar = compute.AnalyzedVar;\n\t\t\t\tvar condVar = compute.condVar;\n\t\t\t\tvar cond1 = compute.cond1VarValues;\n\t\t\t\tvar cond2 = compute.cond2VarValues;\n\t\t\t\tvar trialIData = p.trialIData;\n\t\t\t\tvar avg1 = p.avgCon1;\n\t\t\t\tvar avg2 = p.avgCon2;\n\n\n\t\t\t\t_.each (trialIData, function (value) {\n\t\t\t\t\tvar data = value.data;\n\t\t\t\t\tvar error = data[ErrorVar];\n\t\t\t\t\tvar dataCond = data[condVar];\n\t\t\t\t\tvar diff1 = parcelMng.checkArray(dataCond,cond1);\n\t\t\t\t\tvar diff2 = parcelMng.checkArray(dataCond,cond2);\n\n\t\t\t\t\tif (error=='1'){\n\t\t\t\t\t\tif (diff1){\n\t\t\t\t\t\t\tvalue[AnalyzedVar] += avg1+ penalty;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif (diff2){\n\t\t\t\t\t\t\t\tvalue[AnalyzedVar] += avg2+ penalty;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t}\n\t\t},\n\n/*  Function: Void avgAll.\n\tInput: compute object.\n\tOutput: setting avgCon1 and avgCon2\n\tDescription: Loop over the parcels and Set average for condition 1 trials and for condition 2 trials.\n\n*/\n\n\t\tavgAll: function(compute){\n\t\t\tvar parcelMng = this;\n\t\t\t_.each(parcelMng.parcelArray, function (value) {\n\t\t\t\tparcelMng.avgParcel(value,compute);\n\t\t\t});\n\t\t},\n\n\n/*\n\tprivate\n\tFunction: Void avgParcel.\n\tInput: compute object, parcel.\n\tOutput: setting avgCon1 and avgCon2 in parcel.\n\tDescription: Set average for condition 1 trials and for condition 2 trials in the parcel.\n\n*/\n\n\t\tavgParcel: function(p,compute){\n\t\t\tvar parcelMng = this;\n\t\t\tvar trialIData = p.trialIData;\n\t\t\tvar condVar = compute.condVar;\n\t\t\tvar cond1 = compute.cond1VarValues;\n\t\t\tvar cond2 = compute.cond2VarValues;\n\t\t\tvar AnalyzedVar = compute.AnalyzedVar;\n\t\t\tvar avgCon1 = 0;\n\t\t\tvar avgCon2 = 0;\n\t\t\tvar avgBoth = 0;\n\t\t\tvar numCond1 = 0;\n\t\t\tvar numCond2 = 0;\n\t\t\tvar numBoth = 0;\n\n\t\t\t_.each (trialIData, function (value) {\n\n\t\t\t\tvar AnVar = value[AnalyzedVar];\n\t\t\t\tvar data = value.data;\n\t\t\t\tavgBoth += AnVar;\n\t\t\t\tnumBoth ++;\n\t\t\t\t//var diff1 = ( _(data[condVar]).difference(cond1) );\n\t\t\t\t//var diff2 = ( _(data[condVar]).difference(cond2) );\n\t\t\t\tvar dataCond = data[condVar];\n\t\t\t\tvar diff1 = parcelMng.checkArray(dataCond,cond1);\n\t\t\t\tvar diff2 = parcelMng.checkArray(dataCond,cond2);\n\n\t\t\t\tif (diff1) {\n\t\t\t\t\tnumCond1++;\n\t\t\t\t\tavgCon1 += AnVar;\n\t\t\t\t} else {\n\t\t\t\t\tif (diff2){\n\t\t\t\t\t\tnumCond2++;\n\t\t\t\t\t\tavgCon2 += AnVar;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t});\n\t\t\tif (numCond1 <= 2 || numCond2 <= 2){\n\t\t\t\tparcelMng.scoreData.errorMessage = this.msgMan.getMessage(\"notEnough\");\n\t\t\t}\n\t\t\tif (numCond1 !== 0) {\n\t\t\t\tavgCon1 = avgCon1/numCond1;\n\t\t\t}\n\t\t\tif (numCond2 !== 0) {\n\t\t\t\tavgCon2 = avgCon2/numCond2;\n\t\t\t}\n\t\t\tp.avgCon1 = avgCon1;\n\t\t\tp.avgCon2 = avgCon2;\n\t\t\tp.diff = p.avgCon1 - p.avgCon2;\n\t\t\tif (numBoth !== 0) {\n\t\t\t\tp.avgBoth = avgBoth/numBoth;\n\t\t\t}\n\t\t\tparcelMng.addPenalty(p,compute);\n\t\t},\n\n/*  Function: Void checkArray.\n\tInput: the condition from the trial and an array of condition from computeD object.\n\tOutput: return true if condition is in the array.\n\tDescription: Helper function that returns true if condition is in the array or false otherwise.\n\n*/\n\n\t\tcheckArray: function(conFromData,con){\n\t\t\tfor(var i=0; i<con.length; i++){\n\t\t\t\tvar condition = con[i];\n\t\t\t\tif (condition == conFromData ){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n/*  Function: Void varianceAll.\n\tInput: compute object, parcel.\n\tOutput: variance variable in parcel.\n\tDescription: Loop over the parcels and set the variance variable.\n\n*/\n\n\t\tvarianceAll: function(compute){\n\t\t\tvar parcelMng = this;\n\t\t\t_.each (parcelMng.parcelArray, function (value) {\n\t\t\t\tparcelMng.varianceParcel(value,compute);\n\t\t\t});\n\t\t},\n\n/*  Function: Void varianceParcel.\n\tInput: compute object, parcel.\n\tOutput: setting variance variable in parcel.\n\tDescription: goes over the trials of the parcel and calculate variance.\n\n*/\n\t\tvarianceParcel: function(p,compute){\n\t\t\tvar parcelMng = this;\n\t\t\tvar AnalyzedVar = compute.AnalyzedVar;\n\t\t\tvar trialIData = p.trialIData;\n\t\t\tvar cond1 = compute.cond1VarValues;\n\t\t\tvar cond2 = compute.cond2VarValues;\n\t\t\tvar condVar = compute.condVar;\n\t\t\tvar avg = p.avgBoth;\n\t\t\tvar d = 0;\n\t\t\tvar x2 = 0;\n\t\t\tvar pooledCond1 = [];\n\t\t\tvar pooledCond2 = [];\n\t\t\tvar pooledData = [];\n\t\t\tvar errorLatency = compute.errorLatency;\n\t\t\tvar useForSTD = errorLatency.useForSTD;\n\n\n\t\t\t_.each (trialIData, function (value) {//pool to one array\n\t\t\t\tvar data = value.data;\n\t\t\t\tvar AnVar = value[AnalyzedVar];\n\t\t\t\tvar ErrorVar = compute.ErrorVar;\n\t\t\t\tvar error = data[ErrorVar];\n\t\t\t\tvar dataCond = data[condVar];\n\t\t\t\tvar diff1 = parcelMng.checkArray(dataCond,cond1);\n\t\t\t\tvar diff2 = parcelMng.checkArray(dataCond,cond2);\n\t\t\t\t//var diff1 = ( _(data[condVar]).difference(cond1) );\n\t\t\t\t//var diff2 = ( _(data[condVar]).difference(cond2) );\n\t\t\t\tif (diff1) {\n\t\t\t\t\tif (useForSTD){\n\t\t\t\t\t\tpooledCond1.push(AnVar);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif (error=='0') {\n\t\t\t\t\t\t\tpooledCond1.push(AnVar);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (diff2){\n\t\t\t\t\t\tif (useForSTD){\n\t\t\t\t\t\t\tpooledCond2.push(AnVar);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif (error=='0') {\n\t\t\t\t\t\t\t\tpooledCond1.push(AnVar);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t});\n\n\t\t\tpooledData = pooledCond1.concat(pooledCond2);\n\t\t\t_.each (pooledData, function (value) {//pool to one array\n\t\t\t\tvar AnVar = value;\n\t\t\t\td = AnVar-avg;\n\t\t\t\tx2 += d*d;\n\n\t\t\t});\n\t\t\tp.variance = x2/(pooledData.length-1);\n\t\t},\n\n\n/*  Function: Void scoreAll.\n\tInput: compute object.\n\tOutput: score variable in scoreData object\n\tDescription: Average the scores from all parcels set score in scoreData object.\n\n*/\n\t\tscoreAll: function(compute){\n\t\t\tvar parcelMng = this;\n\t\t\tvar dAvg = 0;\n\t\t\t_.each (parcelMng.parcelArray, function (value) {\n\t\t\t\tparcelMng.scoreParcel(value,compute);\n\t\t\t\tdAvg +=  value.score;\n\t\t\t});\n\t\t\tvar score = (dAvg/(parcelMng.parcelArray.length));\n\t\t\tparcelMng.scoreData.score = score.toFixed(2);\n\n\t\t},\n\n/*\n\tprivate\n\tFunction: Void scoreParcel.\n\tInput: compute object, parcel.\n\tOutput: score variable in parcel\n\tDescription: Calculate the score for the parcel.\n\n*/\n\t\tscoreParcel: function(p){\n\t\t\tvar parcelMng = this;\n\t\t\tvar sd = Math.sqrt(p.variance);\n\t\t\tif (sd === 0){\n\t\t\t\tparcelMng.scoreData.errorMessage = this.msgMan.getMessage(\"notEnough\");\n\t\t\t\tp.score = p.diff;\n\t\t\t} else {\n\t\t\t\tp.score = p.diff/sd;\n\t\t\t}\n\t\t}\n\n\t});\n\n\treturn ParcelMng;\n});\n","define('pipScorer/Scorer',['require','jquery','./computeD','./msgMan','./parcelMng'],function(require){\n\n\tvar $ = require('jquery')\n\t\t, ComputeData = require('./computeD')\n\t\t, MsgMan = require('./msgMan')\n\t\t, ParcelMng = require('./parcelMng');\n\n\t// Description: make sure console.log is safe among all browsers.\n\t// js hint thinks that console is read only - and its correct except where it doesn't exist...  this is how we tell it to ignore these lines\n\t/* jshint -W020 */\n\t!!window.console || (console = {log: $.noop, error: $.noop});\n\tconsole.log || (console.log = $.noop);\n\t/* jshint +W020 */\n\n\n\n\tfunction Scorer(){\n\t\tthis.computeData = new ComputeData();\n\t\tthis.msgMan = new MsgMan();\n\t\tthis.parcelMng = new ParcelMng(this.msgMan);\n\t}\n\n\t$.extend(Scorer.prototype, {\n\n\t\t/**\n\t\t * Set settings for computeD or msgMan\n\t\t * @param {String} type 'compute' or 'message' - the type of settingsObj to set\n\t\t * @param {Object} Obj  The settings object itself\n\t\t */\n\t\taddSettings: function(type,Obj){\n\t\t\tswitch (type){\n\t\t\t\tcase 'compute':\n\t\t\t\t\tthis.computeData.setComputeObject(Obj);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'message':\n\t\t\t\t\tthis.msgMan.setMsgObject(Obj);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('SCORER:addSettings: unknow \"type\" ' + type);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Calculate the score\n\t\t * @return {Object} an object that holds the score and an error message\n\t\t */\n\t\tcomputeD: function(){\n\t\t\tvar computeData = this.computeData;\n\t\t\tvar parcelMng = this.parcelMng;\n\n\t\t\tcomputeData.setDataArray();\n\n\t\t\tparcelMng.Init(computeData);\n\t\t\tparcelMng.avgAll(computeData);\n\n\t\t\tparcelMng.varianceAll(computeData);\n\t\t\tparcelMng.scoreAll(computeData);\n\n\t\t\tvar scoreObj = parcelMng.scoreData;\n\n\t\t\tif (scoreObj.errorMessage === undefined || scoreObj.errorMessage === null){\n\t\t\t\treturn {\n\t\t\t\t\tFBMsg : this.getFBMsg(scoreObj.score),\n\t\t\t\t\tDScore : scoreObj.score,\n\t\t\t\t\terror: false\n\t\t\t\t};\n\t\t\t}else{\n\t\t\t\treturn {\n\t\t\t\t\tFBMsg : scoreObj.errorMessage,\n\t\t\t\t\tDScore : '',\n\t\t\t\t\terror: true\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Post the score and message to the server\n\t\t * @param  {[type]} score    [description]\n\t\t * @param  {[type]} msg      [description]\n\t\t * @param  {String} scoreKey The key with which to send the score data\n\t\t * @param  {String} msgKey   The key with which to send the msg data\n\t\t * @return {promise}         A promise that is resolved with the post\n\t\t */\n\t\tpostToServer: function(score,msg,scoreKey,msgKey){\n\t\t\tvar postSettings = this.computeData.postSettings || {};\n\t\t\tvar url = postSettings.url;\n\t\t\tvar data = {};\n\n\t\t\tif (!scoreKey) {\n\t\t\t\tscoreKey = postSettings.score;\n\t\t\t}\n\n\t\t\tif (!msgKey) {\n\t\t\t\tmsgKey = postSettings.msg;\n\t\t\t}\n\n\t\t\t// create post object\n\t\t\tdata[scoreKey] = score;\n\t\t\tdata[msgKey] = msg;\n\n\t\t\treturn $.post(url,JSON.stringify(data));\n\t\t},\n\n\t\t/**\n\t\t * Blindly post all \"data\" to the server\n\t\t * @param  {Object} data Arbitrary data to be sent to the server\n\t\t * @return {promise}      A promise that is resolved with the post\n\t\t */\n\t\tdynamicPost: function(data){\n\t\t\tvar postSettings = this.computeData.postSettings || {};\n\t\t\tvar url = postSettings.url;\n\n\t\t\treturn $.post(url,JSON.stringify(data));\n\t\t},\n\n\t\t// get message according to user input\n\t\tgetFBMsg: function(DScore){\n\t\t\tvar msg = this.msgMan.getScoreMsg(DScore);\n\t\t\treturn msg;\n\t\t}\n\n\t});\n\treturn Scorer;\n});\ndefine('pipScorer', ['pipScorer/Scorer'], function (main) { return main; });\n\n"]}